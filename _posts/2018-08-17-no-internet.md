---
layout: post
title:  "No Internet"
date:   2018-08-17 15:00:00 +0100
categories: journal
permalink: /2018/08/no-internet
---
If you are reading this, I gained connection to the Internet again. However, this was written in the absolute isolation of a place that has no wifi available, and no access to signal whatsoever. I'm, in modern terms, stranded away from civilisation.

That doesn't mean I don't code, or learn for what is worth. I planned ahead and brought a couple of books with me on my Kindle, but I also wanted to spend some time away from the Internet so that I could code without distractions, and learn on the process.

Oh, my, how untrained I am for the Internetless life.

I still consider myself an amateur, and that's because I'm always learning something new, and am exposed to the obvious fact that __I know nothing__. If you have ever had the feeling that I always know better, this is the part when you are going to be disabused from that notion.

So I am learning Django for real this summer. After doing lots of Data Science and Machine Learning at my previous employer, I am now a Software Engineer. That sounds awesome, but also means that I am at that point where I know that I am underqualified for my next job. And no, that's no impostor syndrome: I have some experience in Web Development, but this is a whole new level.

Good news, I'm not the smartest person in the room, which means I'm in the right room. However, I'm probably going to need to step up if I want to make a living out of this. That's why coming to a remote place where the 21st century hasn't arrived yet sounded like the perfect distraction-free plan. I wasn't counting on the part that Internet is actually a useful thing to rely on if you're stuck.

I'm following along [TDD With Python and Selenium](https://www.amazon.com/Test-Driven-Development-Python-Selenium-JavaScript/dp/1491958707), and I'm finding out how difficult it is to write a book about an open source library: it changes so rapidly, a book is probably outdated the day it's published. The book covers how to do Test Driven Development in Django, which means that I get to write lots of tests about a library that, in principle, I know of. After building my own version of Reddit, I thought this was a different point of view about Django that could help me go deeper into how the library works. And I'm learning more about how difficult it is to apply TDD to real work in real life than about Django.

As it's written, it expects some methods to behave in a way that do not work as expected anymore, and error messages that simply do not appear. Write this test, and write this code and you will see this error message. Well, apparently not. In my humble opinion, books like these are written with good intentions, but only confuse the hell out of people.

This is not, in my defence, my first attempt with this book. In the past, I tried following along with the latest version of Django and hustle my way along the error messages. Believe me when I say: __DON'T__. It would be a waste of time. But, apparently, following along with the recommended Django version doesn't work anymore either, probably because the version I'm using of Python is 3.6, years ahead of what Django 1.11 version (the one in the book) was aiming for in Python. "But someone on the Internet would have found a way around that, wouldn't he?" That's when Internet comes handy, and I don't have it.

Long story short, I'm screwed.

If you recall on a previous post on [persistence](/2018/08/persistence-in software), persistence is the only trait that I believe is an indicator for success.

>How would anyone keep a level of concentration on such mundane tasks, reviewing his own code, looking at error messages, trying to understand the underlying problem and, all in all, systematically hypothesising about expected and unexpected behaviour of the code on the compiler, if one does not have the skill to __not give up__?

That's what I'm building on here: the ability to focus for long periods of time on a certain problem and drill down on error messages, actually understand them, and debug them systematically.

Sounds fun, huh?
